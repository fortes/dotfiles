#!/usr/bin/env bash
# Install some specific packages directly from GitHub. Specifically:
#
# - agg (asciinema gif generator)
# - bun
# - deno
# - difftastic
# - f2
# - fnm
# - fx
# - fzf (because older Debian versions are very old)
# - github cli
# - hugo (latest)
# - jj
# - luals
# - neovim (latest)
# - pistol
# - sad
# - yazi
# - yq
#
# Usage `install_github_packages [package_names...]`

set -euo pipefail
IFS=$'\n\t'
export DEBIAN_FRONTEND=noninteractive

AVAILABLE_PACKAGES=(
  agg
  beads
  bun
  deno
  difftastic
  f2
  fnm
  fx
  fzf
  # Trixie tracks recent version already, can use apt
  # github-cli
  harper-ls
  hugo
  jj
  luals
  neovim
  pistol
  sad
  yazi
  yq
)

print_usage() {
  echo "Usage: ${0} [-h|--help] [-s|--sole-package]"
  echo
  echo "Install packages directly from GitHub. Available packages:"
  echo
  for package in "${AVAILABLE_PACKAGES[@]}"; do
    echo "- ${package}"
  done
  echo
  echo "Options:"
  echo "-h|--help: Show this message"
}

echo_stderr() {
  >&2 echo "${@}"
}

get_current_arch() {
  case "$(uname -m)" in
    x86_64) echo "amd64" ;;  # Standardize to amd64 as primary
    aarch64) echo "arm64" ;; # Standardize to arm64 as primary
    *)
      echo_stderr "Error: Unsupported architecture: $(uname -m)"
      echo_stderr "Supported architectures: x86_64, aarch64"
      exit 1
      ;;
  esac
}

get_arch_patterns() {
  case "$(get_current_arch)" in
    amd64) printf "amd64\nx86_64\n" ;;  # Try amd64 first, fallback to x86_64
    arm64) printf "arm64\naarch64\n" ;; # Try arm64 first, fallback to aarch64
  esac
}

expand_arch_template() {
  local template="$1"
  local arch="$2"
  echo "${template//\{ARCH\}/$arch}"
}

get_latest_release_url() {
  local repo="$1"
  local match_template="$2"
  local urls

  local release_json_url="https://api.github.com/repos/${repo}/releases/latest"
  local release_json
  release_json=$(curl --silent "${release_json_url}")

  # If template contains {ARCH}, try each architecture pattern
  if [[ "${match_template}" == *"{ARCH}"* ]]; then
    local tried_patterns=()
    while IFS= read -r arch; do
      local match_pattern
      match_pattern=$(expand_arch_template "${match_template}" "${arch}")
      tried_patterns+=("${match_pattern}")
      urls=$(echo "${release_json}" | jq -r '.assets[]?.browser_download_url' | grep "${match_pattern}")
      if [[ -n "${urls}" ]]; then
        echo "${urls}" | head -n 1
        return 0
      fi
    done < <(get_arch_patterns)
    echo_stderr "Error: Could not find url for ${repo} matching any of:"
    for pattern in "${tried_patterns[@]}"; do
      echo_stderr "  - ${pattern}"
    done
    echo_stderr "Available assets:"
    while read -r url; do
      echo_stderr "  - $(basename "$url")"
    done < <(echo "${release_json}" | jq -r '.assets[]?.browser_download_url')
    exit 2
  else
    # Original behavior for non-templated patterns
    urls=$(echo "${release_json}" | jq -r '.assets[]?.browser_download_url' | grep "${match_template}")
    if [[ -z "${urls}" ]]; then
      echo_stderr "Error: Could not find url for ${repo} matching ${match_template}"
      exit 2
    fi
    echo "${urls}" | head -n 1
  fi
}

install_bin() {
  local repo="${1}"
  local match="${2}"
  local name="${3:-}"
  if [[ -z "${name}" ]]; then
    name="$(basename "${repo}")"
  fi

  local install_location="$HOME/.local/bin"
  local target_path="${install_location}/${name}"
  
  # Check if already installed
  if [[ -f "${target_path}" ]]; then
    echo "${name} already installed at ${target_path}, skipping"
    return 0
  fi

  local url
  url="$(get_latest_release_url "${repo}" "${match}")"

  mkdir -p "${install_location}"
  echo -n "Downloading ${name} ... "
  wget --quiet -O "${install_location}/${name}" "${url}"
  chmod 755 "${install_location}/${name}"
  echo "${name} installed"
}

install_deb() {
  local repo="${1}"
  local match="${2}"
  local name
  local download_dir

  name="$(basename "${repo}")"

  local url
  url="$(get_latest_release_url "${repo}" "${match}")"

  download_dir="$(mktemp --directory "${name}"XXX)"
  pushd "${download_dir}" >/dev/null
  wget --quiet -O "${name}.deb" "${url}"
  echo "Installing ${repo} (requires sudo) ... "
  sudo dpkg -i "${name}.deb"
  popd >/dev/null
  rm -rf "${download_dir}"
}

install_tarball() {
  local repo="${1}"
  local match="${2}"
  local name="${3:-}"
  if [[ -z "${name}" ]]; then
    name="$(basename "${repo}")"
  fi

  local install_location="$HOME/.local/bin"
  local target_path="${install_location}/${name}"
  
  # Check if already installed
  if [[ -f "${target_path}" ]]; then
    echo "${name} already installed at ${target_path}, skipping"
    return 0
  fi

  local url
  url="$(get_latest_release_url "${repo}" "${match}")"

  local download_dir
  download_dir="$(mktemp --directory "${name}"XXX)"

  pushd "${download_dir}" >/dev/null
  wget --quiet -O "${name}.tar.gz" "${url}"
  echo -n "Expanding ${name}.tar.gz ... "
  tar xvf "${name}.tar.gz" >/dev/null
  if [[ -f "${name}" ]]; then
    mv "${name}" "${install_location}/${name}"
  else
    local file_path
    # File wasn't in the root of the tarball, find matching name to move
    file_path="$(find . -type f -name "${name}")"
    if [[ -n "${file_path}" ]]; then
      mv "${file_path}" "${install_location}/${name}"
    else
      echo_stderr "Error: Could not find ${name} in ${download_dir}"
      find "${download_dir}" -type f
      exit 2
    fi
  fi
  chmod 755 "${install_location}/${name}"
  popd >/dev/null
  rm -rf "${download_dir}"
  echo "${name} installed"
}

install_zip() {
  local repo="${1}"
  local match="${2}"
  local name
  name="$(basename "${repo}")"

  local install_location="$HOME/.local/bin"
  local target_path="${install_location}/${name}"
  
  # Check if already installed
  if [[ -f "${target_path}" ]]; then
    echo "${name} already installed at ${target_path}, skipping"
    return 0
  fi

  local url
  url="$(get_latest_release_url "${repo}" "${match}")"

  mkdir -p "${install_location}"

  local download_dir
  download_dir="$(mktemp --directory "${name}"XXX)"

  pushd "${download_dir}" >/dev/null
  wget --quiet -O "${name}.zip" "${url}"
  echo -n "Unzipping ${name}.zip ... "
  unzip -q -o -j -d . "${name}.zip"

  if [[ -f "${name}" ]]; then
    mv "${name}" "${install_location}/${name}"
    chmod 755 "${install_location}/${name}"
  else
    echo_stderr "Error: Could not find ${name} in ${download_dir}"
    echo_stderr "Available files:"
    find "${download_dir}" -type f -exec basename {} \;
    popd >/dev/null
    rm -rf "${download_dir}"
    exit 2
  fi

  popd >/dev/null
  rm -rf "${download_dir}"
  echo "${name} installed"
}

install_agg() {
  if [[ "$(get_current_arch)" == "arm64" ]]; then
    echo_stderr "Warning: agg is not available for ARM64 architecture"
    return 0
  fi
  install_bin 'asciinema/agg' 'agg-{ARCH}-unknown-linux-musl'
}

install_beads() {
  if [[ "$(get_current_arch)" == "arm64" ]]; then
    echo_stderr "Warning: beads is not available for ARM64 architecture"
    return 0
  fi
  install_tarball 'steveyegge/beads' 'beads_.*_linux_amd64.tar.gz' 'bd'
}

install_bun() {
  # bun uses x64/aarch64 naming instead of standard patterns
  case "$(get_current_arch)" in
    amd64) install_zip 'oven-sh/bun' 'bun-linux-x64.zip' ;;
    arm64) install_zip 'oven-sh/bun' 'bun-linux-aarch64.zip' ;;
  esac
}

install_deno() {
  install_zip 'denoland/deno' 'deno-{ARCH}-unknown-linux-gnu.zip'
}

install_difftastic() {
  install_tarball 'wilfred/difftastic' 'difft-{ARCH}-unknown-linux-gnu.tar.gz' 'difft'
}

install_github_cli() {
  install_deb 'cli/cli' 'gh_.*_linux_{ARCH}.deb'
}

install_f2() {
  install_deb 'ayoisaiah/f2' 'f2_.*_linux_{ARCH}.deb'
}

install_fnm() {
  # fnm uses different naming: x64 for amd64, arm64 for arm64
  case "$(get_current_arch)" in
    amd64) install_zip 'Schniz/fnm' 'fnm-linux.zip' ;;
    arm64) install_zip 'Schniz/fnm' 'fnm-arm64.zip' ;;
  esac
}

install_fx() {
  install_bin 'antonmedv/fx' 'fx_linux_{ARCH}'
}

install_fzf() {
  install_tarball 'junegunn/fzf' 'fzf-.*-linux_{ARCH}.tar.gz'
}

install_hugo() {
  install_deb 'gohugoio/hugo' 'hugo_extended_.*_linux-{ARCH}.deb'
}

install_jj() {
  install_tarball 'jj-vcs/jj' 'jj-v.*-{ARCH}-unknown-linux-musl.tar.gz'
}

install_lua_language_server() {
  local url
  # lua-language-server uses x64/arm64 naming instead of standard patterns
  case "$(get_current_arch)" in
    amd64) url="$(get_latest_release_url 'LuaLS/lua-language-server' 'lua-language-server-.*-linux-x64.tar.gz')" ;;
    arm64) url="$(get_latest_release_url 'LuaLS/lua-language-server' 'lua-language-server-.*-linux-arm64.tar.gz')" ;;
  esac
  local name="lua-language-server"

  local install_location="$HOME/.local/share/lua-language-server"
  
  # Check if already installed
  if [[ -x "${install_location}/bin/lua-language-server" ]]; then
    echo "${name} already installed at ${install_location}, skipping"
    return 0
  fi

  mkdir -p "${install_location}"

  local download_dir
  download_dir="$(mktemp --directory "${name}"XXX)"

  pushd "${download_dir}" >/dev/null
  wget --quiet -O "${name}.tar.gz" "${url}"
  echo -n "Expanding ${name}.tar.gz ... "
  tar xzvf "${name}.tar.gz" -C "${install_location}" >/dev/null

  # Binary is symlinked via stow

  popd >/dev/null
  rm -rf "${download_dir}"
  echo "${name} installed"
}

install_sad() {
  install_deb 'ms-jpq/sad' '{ARCH}-unknown-linux-gnu.deb'
}

install_neovim_stable() {
  local url
  local vim_path="$HOME/.local/bin/nvim"
  local download_dir
  local install_prefix="$HOME/.local"

  # Check if already installed
  if [[ -f "${vim_path}" ]]; then
    echo "neovim already installed at ${vim_path}, skipping"
    return 0
  fi

  echo "Installing neovim stable ..."
  url="$(get_latest_release_url "neovim/neovim" "nvim-linux-{ARCH}.tar.gz")"

  download_dir="$(mktemp --directory nvimXXX)"
  pushd "${download_dir}" >/dev/null
  wget --quiet -O nvim.tar.gz "${url}"
  echo -n "Expanding neovim tarball ... "
  mkdir -p "${install_prefix}"
  tar xzf nvim.tar.gz --strip-components=1 -C "${install_prefix}"
  echo "done"

  popd >/dev/null
  rm -rf "${download_dir}"

  if [[ ! -f "${vim_path}" ]]; then
    echo_stderr "Error: Failed to install Neovim binary at ${vim_path}"
    exit 2
  fi

  chmod 755 "${vim_path}"
  echo "neovim stable installed"

  if [[ -d "$HOME/.local/share/nvim/lazy/lazy.nvim" ]]; then
    echo "Syncing plugins"
    "${vim_path}" --headless "+Lazy! sync" +qa
  else
    echo "Must manually launch Neovim to install plugins"
  fi

  # Don't try to set alternatives if not available
  if ! update-alternatives --query vim &>/dev/null; then
    >&2 echo "update-alternatives not available for vim, skipping"
    return
  fi

  # Assume if it's already set for `vim`, then it's set for the others
  if update-alternatives --list vim | head -n1 | grep -qv "${vim_path}"; then
    echo "Setting neovim as default editor (requires sudo)"
    sudo update-alternatives --install /usr/bin/ex ex "${vim_path}" 110
    sudo update-alternatives --install /usr/bin/vi vi "${vim_path}" 110
    sudo update-alternatives --install /usr/bin/view view "${vim_path}" 110
    sudo update-alternatives --install /usr/bin/vim vim "${vim_path}" 110
    sudo update-alternatives --install /usr/bin/vimdiff vimdiff "${vim_path}" 110
  fi
}

install_pistol() {
  install_bin 'doronbehar/pistol' 'pistol-static-linux-{ARCH}'
}

install_yazi() {
  local url
  # musl version because older Debian versions don't have yazi's required glibc (2.39)
  url="$(get_latest_release_url "sxyazi/yazi" "yazi-{ARCH}-unknown-linux-musl.zip")"

  local bin_location="$HOME/.local/bin"
  local completion_location="$HOME/.local/completion.d/"
  
  # Check if already installed
  if [[ -f "${bin_location}/yazi" ]] && [[ -f "${bin_location}/ya" ]]; then
    echo "yazi already installed at ${bin_location}, skipping"
    return 0
  fi

  local download_dir
  download_dir="$(mktemp --directory yaziXXX)"

  pushd "${download_dir}" >/dev/null
  wget --quiet -O yazi.zip "${url}"
  echo -n "Unzipping yazi.zip ... "
  unzip -q -o -j -d . yazi.zip

  mv -t "${bin_location}" {ya,yazi}
  chmod 755 "${bin_location}"/{ya,yazi}
  mv -t "${completion_location}" yazi.bash
  popd >/dev/null
  rm -rf "${download_dir}"
  echo "yazi installed"
}

install_yq() {
  install_bin 'mikefarah/yq' 'yq_linux_{ARCH}'
}

install_harper_ls() {
  install_tarball 'Automattic/harper' 'harper-ls-{ARCH}-unknown-linux-gnu.tar.gz' 'harper-ls'
}

install_github_packages() {
  # shellcheck source=script/lib.sh
  . "$(dirname "${BASH_SOURCE[0]}")/lib.sh"

  if ! command_exists apt-get; then
    echo_stderr "Only works on Debian-like systems"
    exit 1
  fi

  local packages=("$@")
  if [ "${#packages[@]}" -eq 0 ]; then
    packages=("${AVAILABLE_PACKAGES[@]}")
  fi

  while (("$#")); do
    case "${1}" in
      -h | --help)
        print_usage
        exit 0
        ;;
    esac
    shift
  done

  if [[ -f "${HOME}/.profile.local" ]]; then
    # shellcheck source=/dev/null
    . "${HOME}/.profile.local"
  fi

  echo -n "Installing GitHub packages:"
  printf " %s" "${packages[@]}"
  echo

  for package in "${packages[@]}"; do
    case "${package}" in
      agg)
        install_agg
        ;;
      beads)
        install_beads
        ;;
      bun)
        install_bun
        ;;
      deno)
        install_deno
        ;;
      difftastic)
        install_difftastic
        ;;
      github-cli)
        install_github_cli
        ;;
      f2)
        install_f2
        ;;
      fnm)
        install_fnm
        ;;
      fx)
        install_fx
        ;;
      fzf)
        install_fzf
        ;;
      harper-ls)
        install_harper_ls
        ;;
      hugo)
        install_hugo
        ;;
      luals)
        install_lua_language_server
        ;;
      neovim)
        install_neovim_stable
        ;;
      jj)
        install_jj
        ;;
      pistol)
        install_pistol
        ;;
      sad)
        install_sad
        ;;
      yazi)
        install_yazi
        ;;
      yq)
        install_yq
        ;;
      *)
        echo_stderr "Error: Unrecognized package: ${package}"
        exit 1
        ;;
    esac
  done

  echo "GitHub packages installed!"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  install_github_packages "${@}"
fi
